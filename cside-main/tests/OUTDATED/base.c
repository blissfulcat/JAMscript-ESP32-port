/***********************
* Base testing for tboard_create(), tboard_register_task(), tboard_destroy() and tboard_print_tasks() 
* Last modified: 03/05/2025
* NOTE: Make sure #define MEMORY_DEBUG is uncommented in utils.h 
* USAGE: 
    1. Run the following code as the main function and check if any asserts are not met. 
    2. Compare the related output.txt with the serial output of this program.
***********************/

#include "utils.h"
#include "cnode.h"
#include "task.h"
#include "tboard.h"

/**
 * EXAMPLE FUNCTIONS THAT WE WANT TO ADD TO TBOARD
*/
int example (int a, int b, int c) {
    return 0;
}

void example_2 (char* str, float c) {
    return;
}

/**
 * These function stubs would be generated by the JamScript compiler 
*/
void entry_point_example(execution_context_t* context) {
    arg_t* args = context->query_args;
    int a = args[0].val.ival;
    int b = args[1].val.ival;
    int c = args[2].val.ival;
    int ret = example(a, b, c);
    // context->ret_arg.ival = ret;  // assume that ret_arg has already been allocated
    return;
}

void entry_point_example_2(execution_context_t* context) {
    arg_t* args = context->query_args;
    char* str = args[0].val.sval;
    float c = args[0].val.dval;
    example_2(str, c);
    // context->ret_arg.ival = ret;  // assume that ret_arg has already been allocated
    return;
}

void app_main(void)
{
    /* Create a task for example 1 */
    char* name = "example";
    uint32_t serial_id = 0;
    argtype_t return_type = INT_TYPE;
    char* fn_argsig = "iii"; 
    function_stub_t entry_point = entry_point_example;
    task_t* task = task_create(name, serial_id, return_type, fn_argsig, entry_point);

    assert(task != NULL);
    assert(task->entry_point == entry_point_example);
    assert(strcmp(task->name, "example") == 0);
    assert(task->serial_id == 0);
    assert(task->return_arg->type == INT_TYPE);
    assert(strcmp(task->fn_argsig, "iii") == 0);
    assert(task->is_running == false);
    assert(task->has_finished == false);
    assert(task->task_handle_frtos == NULL);

    /* Create a task for example 2 */
    char* name_2 = "example_2";
    uint32_t serial_id_2 = 1;
    argtype_t return_type_2 = VOID_TYPE;
    char* fn_argsig_2 = "sf"; 
    function_stub_t entry_point_2 = entry_point_example_2;
    task_t* task_2 = task_create(name_2, serial_id_2, return_type_2, fn_argsig_2, entry_point_2);

    assert(task_2 != NULL);
    assert(task_2->entry_point == entry_point_example_2);
    assert(strcmp(task_2->name, "example_2") == 0);
    assert(task_2->serial_id == 1);
    assert(task_2->return_arg->type == VOID_TYPE);
    assert(strcmp(task_2->fn_argsig, "sf") == 0);
    assert(task_2->is_running == false);
    assert(task_2->has_finished == false);
    assert(task_2->task_handle_frtos == NULL);

    /* Create task board */
    tboard_t* tboard = tboard_create();

    assert(tboard != NULL);
    assert(tboard->num_tasks == 0);
    assert(tboard->last_dead_task_id == 0); 
    assert(tboard->num_dead_tasks == 0);
    for (int i = 0; i < MAX_TASKS; i++) {
        assert(tboard->tasks[i] == NULL);
    }
    //assert(tboard->task_management_mutex == NULL);
    //assert(tboard->task_management_mutex_data == NULL);

    /* Register tasks */
    tboard_register_task(tboard, task);
    tboard_register_task(tboard, task_2);

    assert(tboard->tasks[0] == task);
    assert(tboard->tasks[1] == task_2);
    assert(tboard->num_tasks == 2);
    assert(tboard->last_dead_task_id == 0);
    
    /* Try to register a task that is already there */
    tboard_register_task(tboard, task_2);
    assert(tboard->tasks[0] == task);
    assert(tboard->tasks[1] == task_2);
    assert(tboard->num_tasks == 2);
    assert(tboard->last_dead_task_id == 0);

    tboard_print_tasks(tboard);
    
    /* Destroy tboard along with all tasks  */
    tboard_destroy(tboard);
    assert(total_mem_usage == 0);

    /* Loop forever */
    while (true) {
        sleep(1);
    }
}