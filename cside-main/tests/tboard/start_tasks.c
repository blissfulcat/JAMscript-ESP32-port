/***********************
* More comprehensive test of tboard. Mostly testing: tboard_find_task_id(), tboard_find_task_name(), tboard_start_task_id(), tboard_start_task_name().
*
* Three different tasks are added to the tboard, two synchronous tasks and one asynchronous task (infinite loop). 
* All tasks are constructed using task_create() constructor, registered to the tboard via tboard_register_task().
* First, the infinite loop task is started and is running while we run the other two synchronous tasks in order.
* One of the tasks has a return value, which is returned inside of task->ret_arg->val after the FreeRTOS task returns.
* Use the #define USE_START_TASK_NAME to toggle between testing the tboard_start_task_name() and tboard_start_task_id().
*
* Last modified: 03/05/2025
* NOTE: Make sure #define MEMORY_DEBUG is uncommented in utils.h 
* USAGE: 
1. Run the following code as the main function and check if any asserts are not met. 
2. Compare the related output.txt with the serial output of this program.
***********************/

#include "utils.h"
#include "cnode.h"
#include "task.h"
#include "tboard.h"

#define USE_START_TASK_NAME /// Uncomment this to start tasks using tboard_start_task_id() instead.

/**
 * EXAMPLE FUNCTIONS THAT WE WANT TO ADD TO TBOARD
*/
int example (int a, int b, int c) {
    return a+b+c; /* Synchronous task with return value */
}

void example_2 (char* str, float c) {
    printf("Hello from example_2: %s\n", str); /* Synchronous task without return value */
    return;
}

void inf_loop(void) {
    while(1) {
        vTaskDelay(1); /* This line would be added by the compiler, or taskYIELD() (cooperative multithreading), since this task is ASYNC */
    }
}

/**
 * These function stubs would be generated by the JamScript compiler based on the implementations above.
*/
void entry_point_example(execution_context_t* context) {
    arg_t** args = context->query_args;
    int a = args[0]->val.ival;
    int b = args[1]->val.ival;
    int c = args[2]->val.ival;
    int ret = example(a, b, c);
    context->return_arg->val.ival = ret;
    return;
}

void entry_point_example_2(execution_context_t* context) {
    arg_t** args = context->query_args;
    char* str = args[0]->val.sval;
    float c = args[0]->val.dval;
    example_2(str, c);
    return;
}

void entry_point_inf_loop(execution_context_t* context) {
    // this function has no arguments
    inf_loop();
}

void app_main(void)
{
    /* Create the inf loop task */
    char* il_name = "inf_loop";
    uint32_t il_serial_id = 2;
    argtype_t il_return_type = VOID_TYPE;
    char* il_fn_argsig = "";
    function_stub_t il_entry_point = entry_point_inf_loop;
    task_t* il_task = task_create(il_name, il_serial_id, il_return_type, il_fn_argsig, il_entry_point);
    
    assert(il_task != NULL);
    assert(il_task->entry_point == entry_point_inf_loop);
    assert(strcmp(il_task->name, "inf_loop") == 0);
    assert(il_task->serial_id == 2);
    assert(il_task->return_arg->type == VOID_TYPE);
    assert(strcmp(il_task->fn_argsig, "") == 0);
    assert(il_task->is_running == false);
    assert(il_task->has_finished == false);
    assert(il_task->task_handle_frtos == NULL);

    /* Create a task for example 1 */
    char* name = "example";
    uint32_t serial_id = 0;
    argtype_t return_type = INT_TYPE;
    char* fn_argsig = "iii"; 
    function_stub_t entry_point = entry_point_example;
    task_t* task = task_create(name, serial_id, return_type, fn_argsig, entry_point);

    assert(task != NULL);
    assert(task->entry_point == entry_point_example);
    assert(strcmp(task->name, "example") == 0);
    assert(task->serial_id == 0);
    assert(task->return_arg->type == INT_TYPE);
    assert(strcmp(task->fn_argsig, "iii") == 0);
    assert(task->is_running == false);
    assert(task->has_finished == false);
    assert(task->task_handle_frtos == NULL);

    /* Create a task for example 2 */
    char* name_2 = "example_2";
    uint32_t serial_id_2 = 1;
    argtype_t return_type_2 = VOID_TYPE;
    char* fn_argsig_2 = "sf"; 
    function_stub_t entry_point_2 = entry_point_example_2;
    task_t* task_2 = task_create(name_2, serial_id_2, return_type_2, fn_argsig_2, entry_point_2);

    assert(task_2 != NULL);
    assert(task_2->entry_point == entry_point_example_2);
    assert(strcmp(task_2->name, "example_2") == 0);
    assert(task_2->serial_id == 1);
    assert(task_2->return_arg->type == VOID_TYPE);
    assert(strcmp(task_2->fn_argsig, "sf") == 0);
    assert(task_2->is_running == false);
    assert(task_2->has_finished == false);
    assert(task_2->task_handle_frtos == NULL);

    /* Create task board */
    tboard_t* tboard = tboard_create();

    assert(tboard != NULL);
    assert(tboard->num_tasks == 0);
    assert(tboard->last_dead_task_id == 0); 
    assert(tboard->num_dead_tasks == 0);
    for (int i = 0; i < MAX_TASKS; i++) {
        assert(tboard->tasks[i] == NULL);
    }
    //assert(tboard->task_management_mutex == NULL);
    //assert(tboard->task_management_mutex_data == NULL);

    /* Register tasks */
    tboard_register_task(tboard, task);
    tboard_register_task(tboard, task_2);
    tboard_register_task(tboard, il_task);

    assert(tboard->tasks[0] == task);
    assert(tboard->tasks[1] == task_2);
    assert(tboard->tasks[2] == il_task);
    assert(tboard->num_tasks == 3);
    assert(tboard->last_dead_task_id == 0);
    
    /* Try to register a task that is already there */
    tboard_register_task(tboard, task_2);

    /* Testing find_task_id and find_task_name functions */
    task_t* found_task_1;
    task_t* found_task_2;
    task_t* found_task_3;

    found_task_1 = tboard_find_task_id(tboard, 0);
    found_task_2 = tboard_find_task_id(tboard, 1);
    found_task_3 = tboard_find_task_id(tboard, 2);

    assert(found_task_1 == task);
    assert(found_task_2 == task_2);
    assert(found_task_3 == il_task);

    found_task_1 = tboard_find_task_name(tboard, "example");
    found_task_2 = tboard_find_task_name(tboard, "example_2");
    found_task_3 = tboard_find_task_name(tboard, "inf_loop");

    assert(found_task_1 == task);
    assert(found_task_2 == task_2);
    assert(found_task_3 == il_task);

    /* Start the infinite loop task */
    printf("Starting infinite loop task\n");
    #ifdef USE_START_TASK_NAME
    assert(tboard_start_task_name(tboard, "inf_loop", NULL));
    #else
    assert(tboard_start_task_id(tboard, 2, NULL));
    #endif
    /* Start task 1 */
    /* Generate arguments */
    arg_t arg1 = {.type = INT_TYPE, .val.ival = 1};
    arg_t arg2 = {.type = INT_TYPE, .val.ival = 2};
    arg_t arg3 = {.type = INT_TYPE, .val.ival = 3};

    /* Set the args using variable arguments */
    task_set_args(task, 3, &arg1, &arg2, &arg3);
    assert(strlen(task->fn_argsig) == 3);
    arg_t** args = task_get_args(task);

    assert(args != NULL);
    assert(args[0]->type = INT_TYPE);
    assert(args[0]->val.ival = 1);
    assert(args[1]->type = INT_TYPE);
    assert(args[1]->val.ival = 2);
    assert(args[2]->type = INT_TYPE);
    assert(args[2]->val.ival = 3);
    printf("Starting task 1\n");
    #ifdef USE_START_TASK_NAME
    assert(tboard_start_task_name(tboard, "example", args));
    #else
    assert(tboard_start_task_id(tboard, 0, args));
    #endif

    while (!task->has_finished) {
        sleep(1);
    }
    printf("Task 1 finished with return value: %d\n", task->return_arg->val.ival);

    assert(task->return_arg->val.ival == 6);
    assert(task->is_running == false);
    assert(task->has_finished == true);
    assert(tboard->last_dead_task_id == 0);
    assert(tboard->num_dead_tasks == 1);

    /* Start task 2 */
    /* Generate arguments */
    arg_t t2_arg1 = {.type = STRING_TYPE, .val.sval = "bruh"};
    arg_t t2_arg2 = {.type = DOUBLE_TYPE, .val.dval = 2.5f};

    /* Set the args using variable arguments */
    task_set_args(task_2, 2, &t2_arg1, &t2_arg2);
    assert(strlen(task_2->fn_argsig) == 2);
    arg_t** args_2 = task_get_args(task);

    assert(strcmp(t2_arg1.val.sval, "bruh") == 0);
    assert(args_2 != NULL);
    assert(args_2[0]->type = STRING_TYPE);
    //assert(strcmp(args_2[0]->val.sval, "bruh") == 0); NOTE: for some reason this line causes the program to crash.
    assert(args_2[1]->type = DOUBLE_TYPE);
    assert(args_2[1]->val.dval = 2.5f);
    printf("Starting task 2\n");
    #ifdef USE_START_TASK_NAME
    assert(tboard_start_task_name(tboard, "example_2", NULL));
    #else
    assert(tboard_start_task_id(tboard, 1, args_2));
    #endif
    
    while (!task_2->has_finished) {
        sleep(1);
    }

    assert(task->is_running == false);
    assert(task->has_finished == true);
    assert(tboard->last_dead_task_id == 1);
    assert(tboard->num_dead_tasks == 2);
    
    /* Display tboard status */
    tboard_print_tasks(tboard);

    /* Destroy tboard along with all tasks  */
    tboard_destroy(tboard);
    assert(total_mem_usage == 0);

    /* Loop forever */
    while (true) {
        sleep(1);
    }
}