/***********************
* Refactor task.c/task.h comprehensive tests. 
*
* Creating tasks test (multiple types of tasks with different return and argsig)
* Creating instances test 
* Creating duplicate instance test
* Exceeding maximum number of instances test
* Setting and getting arguments test
* Setting incorrect argument test
* Destructor/Memory leak test
* 
* Last modified: 03/23/2025
* NOTE: Make sure #define MEMORY_DEBUG is uncommented in utils.h 
* USAGE: 
1. Run the following code as the main function and check if any asserts are not met. 
2. Compare the related output.txt with the serial output of this program.
***********************/

#include "utils.h"
#include "cnode.h"
#include "task.h"
#include "tboard.h"

#define USE_START_TASK_NAME /// Uncomment this to start tasks using tboard_start_task_id() instead.

/**
 * EXAMPLE FUNCTIONS THAT WE WANT TO ADD TO TBOARD
*/
int example (int a, int b, int c) {
    return a+b+c; /* Synchronous task with return value */
}

void example_2 (char* str, float c) {
    printf("Hello from example_2: %s\n", str); /* Synchronous task without return value */
    return;
}

void inf_loop(void) {
    while(1) {
        vTaskDelay(1); /* This line would be added by the compiler, or taskYIELD() (cooperative multithreading), since this task is ASYNC */
    }
}

/**
 * These function stubs would be generated by the JamScript compiler based on the implementations above.
*/
void entry_point_example(execution_context_t* context) {
    arg_t** args = context->query_args;
    int a = args[0]->val.ival;
    int b = args[1]->val.ival;
    int c = args[2]->val.ival;
    int ret = example(a, b, c);
    context->return_arg->val.ival = ret;
    return;
}

void entry_point_example_2(execution_context_t* context) {
    arg_t** args = context->query_args;
    char* str = args[0]->val.sval;
    float c = args[0]->val.dval;
    example_2(str, c);
    return;
}

void entry_point_inf_loop(execution_context_t* context) {
    // this function has no arguments
    inf_loop();
}

void app_main(void)
{
    /* Create the inf loop task */
    char* il_name = "inf_loop";
    argtype_t il_return_type = VOID_TYPE;
    char* il_fn_argsig = "";
    function_stub_t il_entry_point = entry_point_inf_loop;
    task_t* il_task = task_create(il_name, il_return_type, il_fn_argsig, il_entry_point);
    
    assert(il_task != NULL);
    assert(il_task->entry_point == entry_point_inf_loop);
    assert(strcmp(il_task->name, "inf_loop") == 0);
    assert(il_task->return_type == VOID_TYPE);
    assert(strcmp(il_task->fn_argsig, "") == 0);
    for (int i = 0; i < MAX_INSTANCES; i++) assert(il_task->instances[i] == NULL);
    assert(il_task->num_instances == 0);
    printf("Create infinite loop passed \r\n");

    /* Create a task for example 1 */
    char* name = "example";
    argtype_t return_type = INT_TYPE;
    char* fn_argsig = "iii"; 
    function_stub_t entry_point = entry_point_example;
    task_t* task = task_create(name, return_type, fn_argsig, entry_point);

    assert(task != NULL);
    assert(task->entry_point == entry_point_example);
    assert(strcmp(task->name, "example") == 0);
    assert(task->return_type == INT_TYPE);
    assert(strcmp(task->fn_argsig, "iii") == 0);
    for (int i = 0; i < MAX_INSTANCES; i++) assert(task->instances[i] == NULL);
    assert(task->num_instances == 0);
    printf("Create example 1 task passed \r\n");

    /* Create a task for example 2 */
    char* name_2 = "example_2";
    argtype_t return_type_2 = VOID_TYPE;
    char* fn_argsig_2 = "sf"; 
    function_stub_t entry_point_2 = entry_point_example_2;
    task_t* task_2 = task_create(name_2, return_type_2, fn_argsig_2, entry_point_2);

    assert(task_2 != NULL);
    assert(task_2->entry_point == entry_point_example_2);
    assert(strcmp(task_2->name, "example_2") == 0);
    assert(task_2->return_type == VOID_TYPE);
    assert(strcmp(task_2->fn_argsig, "sf") == 0);
    for (int i = 0; i < MAX_INSTANCES; i++) assert(task_2->instances[i] == NULL);
    assert(task_2->num_instances == 0);
    printf("Create example 2 task passed \r\n");

    /* Create specific task instance of the infinite loop task with serial ID = 0*/
    task_instance_t* il_task_inst = task_instance_create(il_task, 0);
    assert(il_task->num_instances == 1);
    assert(il_task->instances[0] == il_task_inst);
    for (int i = 1; i < MAX_INSTANCES; i++) assert(il_task->instances[i] == NULL);
    assert(il_task_inst != NULL);
    assert(il_task_inst->is_running == false);
    assert(il_task_inst->has_finished == false);
    assert(il_task_inst->parent_task == il_task);
    assert(il_task_inst->return_arg->type == il_task->return_type);
    assert(il_task_inst->serial_id == 0);
    printf("Create single task instance passed \r\n");

    /* Trying to create a duplicate instance (same serial ID) */
    task_instance_t* il_task_inst_dup = task_instance_create(il_task, 0);
    assert(il_task_inst_dup == NULL);
    assert(il_task->num_instances == 1);
    assert(il_task->instances[0] == il_task_inst);
    for (int i = 1; i < MAX_INSTANCES; i++) assert(il_task->instances[i] == NULL);
    printf("Create duplicate task test passed \r\n");

    /* Create a bunch of instances until the maximum is reached */
    for (int i = 0; i < MAX_INSTANCES+1; i++) {
        task_instance_create(task_2, i);
    }
    assert(task_2->num_instances == MAX_INSTANCES);
    for (int i = 0; i < MAX_INSTANCES; i++) assert(task_2->instances[i] != NULL);
    printf("Maximum task instances test passed \r\n ");

    /* Generate arguments */
    arg_t arg1 = {.type = INT_TYPE, .val.ival = 1};
    arg_t arg2 = {.type = INT_TYPE, .val.ival = 2};
    arg_t arg3 = {.type = INT_TYPE, .val.ival = 3};

    arg_t* set_args[3];
    set_args[0] = &arg1;
    set_args[1] = &arg2;
    set_args[2] = &arg3;

    task_instance_t* task_inst = task_instance_create(task, 0);
    assert(task_inst != NULL);
    assert(task_inst->parent_task != NULL);

    /* Set the args using normal set_args */
    if (!task_instance_set_args(task_inst, set_args, 3)) {
        return;
    }
    assert(strlen(task_inst->parent_task->fn_argsig) == 3);
    arg_t** args = task_instance_get_args(task_inst);
    assert(args != NULL);
    assert(args[0]->type == INT_TYPE);
    assert(args[0]->val.ival == 1);
    assert(args[1]->type == INT_TYPE);
    assert(args[1]->val.ival == 2);
    assert(args[2]->type == INT_TYPE);
    assert(args[2]->val.ival == 3);
    printf("Set and get arguments test passed \r\n");

    /* Incorrect argument passed test */
    arg3.type = DOUBLE_TYPE;
    arg3.val.dval = 3.0;

    /* Set the args using normal set_args */
    assert(task_instance_set_args(task_inst, set_args, 3) == false);
    printf("Set incorrect argument test passed \r\n");


    task_destroy(il_task);
    task_destroy(task);
    task_destroy(task_2);
    assert(total_mem_usage == 0);
    printf("Memory leak test passed \r\n");

    /* Loop forever */
    while (true) {
        sleep(1);
    }
}